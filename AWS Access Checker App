from flask import Flask, request, render_template_string
import boto3
from ipaddress import ip_address, ip_network
import botocore.exceptions

app = Flask(__name__)
ec2 = boto3.client('ec2')

HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head><title>AWS Access Checker</title></head>
<body>
  <h2>AWS Access Checker</h2>
  <form method="post">
    Source (IP / SG ID / PL ID): <input type="text" name="source"><br>
    Destination IP: <input type="text" name="destination"><br>
    Port: <input type="text" name="port"><br>
    Protocol (TCP/UDP/ALL): <input type="text" name="protocol" value="tcp"><br>
    <input type="submit" value="Check">
  </form>
  {% if result %}
  <h3>Result</h3>
  <pre>{{ result }}</pre>
  {% endif %}
</body>
</html>
'''

def ip_in_cidr(ip, cidr):
    try:
        return ip_address(ip) in ip_network(cidr)
    except ValueError:
        return False

def find_ips_in_source_sg(sg_id):
    try:
        ips = set()
        enis = ec2.describe_network_interfaces(Filters=[
            {'Name': 'group-id', 'Values': [sg_id]}
        ])['NetworkInterfaces']
        for eni in enis:
            ips.add(eni['PrivateIpAddress'])
            for p in eni.get('PrivateIpAddresses', []):
                ips.add(p['PrivateIpAddress'])
        return ips
    except botocore.exceptions.ClientError as e:
        return set()

def is_ip_allowed_by_prefix_lists(source_ip, prefix_list_ids):
    for pl_id in prefix_list_ids:
        try:
            pl_info = ec2.describe_managed_prefix_lists(PrefixListIds=[pl_id])['PrefixLists'][0]
            version = pl_info['Version']
            entries = ec2.get_managed_prefix_list_entries(PrefixListId=pl_id, TargetVersion=version)['Entries']
            for entry in entries:
                if ip_in_cidr(source_ip, entry['Cidr']):
                    return True, pl_id
        except botocore.exceptions.ClientError as e:
            print(f"Error retrieving prefix list {pl_id}: {e}")
    return False, None

def get_enis_for_destination_ip(dest_ip):
    try:
        matching_enis = []
        all_enis = ec2.describe_network_interfaces()['NetworkInterfaces']
        for eni in all_enis:
            if eni.get('PrivateIpAddress') == dest_ip:
                matching_enis.append(eni['NetworkInterfaceId'])
            for p in eni.get('PrivateIpAddresses', []):
                if p.get('PrivateIpAddress') == dest_ip:
                    matching_enis.append(eni['NetworkInterfaceId'])
        return matching_enis
    except botocore.exceptions.ClientError as e:
        print(f"Error retrieving ENIs for destination IP {dest_ip}: {e}")
        return []

def check_access(source, destination, port, protocol):
    try:
        port = int(port)
    except ValueError:
        return "Invalid port number provided."

    protocol = protocol.lower()
    if protocol not in ['tcp', 'udp', 'all']:
        return "Invalid protocol. Please use TCP, UDP, or ALL."

    result_lines = []
    source_is_ip = False
    if source.count('.') == 3:
        source_is_ip = True

    eni_ids = get_enis_for_destination_ip(destination)
    if not eni_ids:
        return f"No ENIs found for destination IP {destination}. Please ensure it is a private IP used by an EC2, ALB, Lambda, or RDS resource."

    for eni_id in eni_ids:
        try:
            eni = ec2.describe_network_interfaces(NetworkInterfaceIds=[eni_id])['NetworkInterfaces'][0]
        except botocore.exceptions.ClientError as e:
            result_lines.append(f"Error retrieving ENI {eni_id}: {e}")
            continue

        for group in eni.get('Groups', []):
            sg_id = group['GroupId']
            try:
                sg_data = ec2.describe_security_groups(GroupIds=[sg_id])['SecurityGroups'][0]
            except botocore.exceptions.ClientError as e:
                result_lines.append(f"Error retrieving SG {sg_id}: {e}")
                continue

            for perm in sg_data.get('IpPermissions', []):
                perm_proto = perm.get('IpProtocol')
                if protocol != 'all' and perm_proto not in [protocol, '-1']:
                    continue
                if perm.get('FromPort') is not None and perm.get('ToPort') is not None:
                    if not (perm['FromPort'] <= port <= perm['ToPort']):
                        continue

                for ip_range in perm.get('IpRanges', []):
                    if 'CidrIp' in ip_range and ip_in_cidr(source, ip_range['CidrIp']):
                        result_lines.append(f"✅ Allowed by SG {sg_id} via direct IP {source} in CIDR {ip_range['CidrIp']}")

                if source_is_ip:
                    for sg_ref in perm.get('UserIdGroupPairs', []):
                        source_ips = find_ips_in_source_sg(sg_ref['GroupId'])
                        if source in source_ips:
                            result_lines.append(f"✅ Allowed by SG {sg_id} via source IP {source} (mapped from SG {sg_ref['GroupId']})")

                    pl_ids = [pl['PrefixListId'] for pl in perm.get('PrefixListIds', [])]
                    allowed, pl_id = is_ip_allowed_by_prefix_lists(source, pl_ids)
                    if allowed:
                        result_lines.append(f"✅ Allowed by SG {sg_id} via Prefix List {pl_id} matching source IP {source}")

                elif source.startswith('sg-'):
                    for sg_ref in perm.get('UserIdGroupPairs', []):
                        if sg_ref['GroupId'] == source:
                            result_lines.append(f"✅ Allowed by SG {sg_id} via referenced SG {source}")

                elif source.startswith('pl-'):
                    for pl in perm.get('PrefixListIds', []):
                        if pl['PrefixListId'] == source:
                            result_lines.append(f"✅ Allowed by SG {sg_id} via Prefix List {source}")

    return "\n".join(result_lines) if result_lines else "❌ Access NOT allowed based on available SG rules."

@app.route('/', methods=['GET', 'POST'])
def index():
    result = ''
    if request.method == 'POST':
        source = request.form['source'].strip()
        destination = request.form['destination'].strip()
        port = request.form['port'].strip()
        protocol = request.form['protocol'].strip()
        result = check_access(source, destination, port, protocol)
    return render_template_string(HTML_TEMPLATE, result=result)

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5656)
